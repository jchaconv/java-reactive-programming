Java - Reactive Programming

*********************************************************************************************************
                                        Section 1 : Introduction
*********************************************************************************************************

Index:

- Process / Thread / RAM / CPU / Scheduler
- Sync / Async / Non-Blocking / Non-Blocking + Async
- IO communication patterns
- Reactive programming
        . What is it?
        . Why do we need it?
        . How does it work?
        . Why can I not use virtual threads?
        . Principles of reactive programming



*********************************************************************************************************

                                        Lesson 1 - some theory


OOP pillars:
- abstraction
- encapsulation
- inheritance
- polymorphism

Reactive programming concepts:

- non-blocking
- asynchronous
- stream based communication
- backpressure handling


/// Process / Thread / RAM / CPU / Scheduler ///


Process: allocated in RAM
    Thread: a part of the process, it's related to execution
    
Scheduler: it determines the order and duration of thread execution

CPU: responsible of process execution


*********************************************************************************************************

                                        Lesson 2 - IO Models


Inbound / Outbound  (4 types)

- Sync
    It's blocking. Similar to call center interaction.
    You can't do nothing until the agent response you back.



- Async
    Ex: I called my friend and ask him to call the insurance company.
    The main concept is delegation. I have no necessity of wait a response.
    A thread is created to do the delegation of the task. But my friend is still blocked.



- non-blocking
    Ex: I give my number to the call center and an agent call me later.
    A thread send the request and it's free to do some other task. After some time I receive
    a notification.



- non-blocking + async
    Ex: I give my friend's number and an agent call him back later.
    The second application send the notifition and my OS use another thread to do the task.


*********************************************************************************************************

                    Lesson 3 - Why can I not use virtual threads?

Communication patterns:


    - request -> response (classic)
        Whit this approch virtual threads are enough, but reactive programming has more than this king of
        communication.

    - request -> streaming response          ex: delivery food
            <--------------
    

    - streaming request     response         ex: apple watch, google docs
        -------------------->
                              <-


    - bidirectional streaming                ex: exchanging messages like humans talk
      ----------------------->
      <-----------------------



*********************************************************************************************************

                                Lesson 4 - What is reactive programming?


It's a paradigm designed to process "streams of messages" in a "non-blocking" and "asynchronous" manner,
while handling "back pressure". It's base on Observer pattern.


*********************************************************************************************************

                                Lesson 5 - Streams specification


Observer pattern consists in react to other actions like dependency cells with formulas in sheets

    Publisher
        - subscribe()

    Processor: Hybrid between Publisher and Subscriber

    Subscription
        - request()
        - cancel()

    Subscriber
        - onSubscribe()
        - onNext()
        - onError()
        - onComplete()


Reactive streams - Implementation

    - Akka streams
    - rxJava2
    - Reactor
        . Spring Webflux
        . R2DBC (Postgres, MySQL, H2)
        . Redis
        . ElasticSearch
        . Mongo
        . Kafka
        . RabbitMQ
    

*********************************************************************************************************

                                Lesson 6 - Publisher / Subscriber Communication



Step1: Subscriber wants to connect
----------------------------------


        Publisher   <-----------------      Subscriber


The Subscriber wants to get information or updates from the Publisher.
The Subscriber uses the subscribe() method of Publisher interface to get the data.


Step2: Publisher calls onSubscribe
----------------------------------

The Publisher receives the Subscriber request and give the Subscription object throgh
onSubscribe() method of Subscriber interface.


        Publisher   <-----------------          Subscriber
                    -> [Object(Subscription)]


Step3: Subscription
-------------------

At this point the communication between Publisher and Subscriber is doing through
the Subscription. If the Subscriber wants some update from the Publisher it uses the
request() method of Subscription interface. Otherwise it uses cancel() method.


Publisher                                            Subscriber
    ^                                                    |
    |                                                    | 
    --------------  Subscription  <----------------------


Step4: Publisher pushes data via onNext
----------------------------------------

The Publisher use the onNext() method of the Subscriber to returns the requested information.
The Subscriber requests for 3 items and the Publisher gives 3 items.

                                    *  *  *
Publisher   ---------------------------------------> Subscriber
    ^                                                    |
    |                                                    | 
    --------------  Subscription  <----------------------   request = 3


Step5: onComplete
------------------

When the Publisher has no item to emit, it calls the onComplete method to notify the Subscriber
that the requested items have already been emitted.
The communication is ended at this point.


Publisher   ----------------->     Subscriber



Step6: onError
---------------

If the Publisher has a problem processing the request, it uses the onError method no notify the issue to the Subscriber.
The Subscriber will not send anything after onError.



Terminologies (synonyms):
-------------

. Publisher
    - Source
    - Observable
    - Upstream
    - Producer


. Subscriber
    - Sink
    - Observer
    - Downstream
    - Consumer


. Processor
    - Operator



*********************************************************************************************************
                                        Section 2 : Mono
*********************************************************************************************************

                                    Lesson 7 - Setup project

name: reactive-programming-playground
package: com.jchaconv
java: 21
pom.xml: copy and paste dependencies & properties
logback.xml in resource folder

to get the correct version of java 21 delete the keys in the path of environment variables

Prestar atención a las dependencias, no tenía la de starter web y la de testing, tuve que agregarlas para evitar
errores de compilación.


*********************************************************************************************************

                        Lesson 8 - Publisher / Subscriber Implementation


It's a fake Implementation of the different interfaces and see how they interact between them.
Not necessary, go to the next lesson.

sec02.publisher
sec02.subscriber

*********************************************************************************************************

                        Lesson 9 - Mono / Flux Introduction

Reactor is an implementation of reactive streams, something like Hibernate to Jpa.                        
Reactor has to interfaces: Mono and Flux.

(They are Publishers)

Mono:
    - It emits 0 or 1 item
    - Followed by an onComplete / onError

Flux:
    - It emits 0, 1 or N items
    - Followed by an onComplete / onError


                        Lesson 10 - Why do we need Mono?

Si solo espero 0 o 1 item es mejor usar Mono. Por ejemplo, cuando busco un usuario por id (findById)

    Flux:
        - Stream of messages
        - Backpressure (¿Qué sucede cuando un Consumer no puede manejar todos los mensajes que emite un Publisher?)
            is a mechanism that allows a consumer to signal a producer to slow down when data is being emitted
            faster than it can be consumed
        - Many additional methods specific to handle stream processing
    
    Mono:
        - No Stream!
        - No Backpressure
        - A ligth weight publisher
        - Good for Request -> Response model


*********************************************************************************************************

                        Lesson 11 - Lazy Stream


Los streams son Lazy ya que no ejecutan nada si no tienen un "terminal operator"

La programación reactiva es similar porque está en un estilo functional y no se ejecutará nada hasta llamar
o conectar al subscriber.

sec02.Lec01LazyStream.java                        

*********************************************************************************************************


just            ->  When the value is in memory already
empty           ->  No item to emit
error           ->  Emit error
fromSupplier    ->  defer execution by using Supplier<T>
fromCallable    ->  defer execution by using Callable<T>
fromFuture      ->  Publisher from CompletableFuture<T>


                    Lesson 12 - Mono just

El método subscribe acepta un Subscriber o un Consumer y luego de setearlo se tiene que hacer el request mediante el
subscription. Es la manera de crear un publisher Mono.just("julio");



sec02.Lec02MonoJust.java


*********************************************************************************************************


                                        Lesson 13 - Mono Subscribe

Se usa el método mono.subscribe(), puede recibir uno o más parámetros
en el ejemplo se está proporcionando:
    - el primer consumer para emitir
    - el segundo para loggear el error
    - Runnable para loggear un mensaje de completado
    - y el subscription no es necesario porque el request se hace automáticamente

Además luego de mono.just(1) se puede hacer transformación con map() 


*********************************************************************************************************





*********************************************************************************************************


*********************************************************************************************************


*********************************************************************************************************


*********************************************************************************************************


*********************************************************************************************************


*********************************************************************************************************































